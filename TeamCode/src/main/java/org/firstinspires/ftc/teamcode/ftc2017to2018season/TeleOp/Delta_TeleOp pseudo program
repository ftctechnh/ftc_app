package org.firstinspires.ftc.teamcode.ftc2017to2018season.TeleOp;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;


/**
 * Created by Pahel and Rohan on 11/18/17.
 */


@TeleOp(name = "Delta_TeleOp_2")
//@Disabled
public class Delta_TeleOp_2 extends OpMode {
/*Delta_TeleOp is designed for and tested with the Tile Runner robot. If this program is used with another robot it may not worked.
* This is specificly made for the Tile Runner and not another pushbot or competiotion robot. However, this program is the basic design for
* simple program and could work on a different robot with simple debugging and configuration.*/

    /*
        ---------------------------------------------------------------------------------------------

       Define the actuators we use in the robot here
    */
    to declare = to tell the program what is on the robot

    DcMotor leftWheelMotorFront;
    DcMotor leftWheelMotorBack;
    DcMotor rightWheelMotorFront;
    DcMotor rightWheelMotorBack;
    These four motors are the ones used for movement and they are declared here

    DcMotor slideMotor;
    This is the motor used to move the linear slide carrying the glyph manipulator which is declared here

    Servo glyphServoRight;
    Servo glyphServoLeft;
    These two servos are used to open and close the glyph manipulator

    Initial value for slide motor. This is used further down in the program for incremental movement.
    public int IVFSM;

    @Override
    public void init() {
        leftWheelMotorFront = hardwareMap.dcMotor.get("leftWheelMotorFront");
        leftWheelMotorBack = hardwareMap.dcMotor.get("leftWheelMotorBack");
        rightWheelMotorFront = hardwareMap.dcMotor.get("rightWheelMotorFront");
        rightWheelMotorBack = hardwareMap.dcMotor.get("rightWheelMotorBack");
        In this we tell the program or Android Studios that the things we named above are peices of harware on the robot.
        These four wheels are the ones used for movement.

        glyphServoRight = hardwareMap.servo.get("glyphServoRight");
        glyphServoLeft = hardwareMap.servo.get("glyphServoLeft");
        In this we tell the program or Android Studios that the things we named above are peices of harware on the robot.
        These are the servos used for opening and closing the claw

        slideMotor = hardwareMap.dcMotor.get("slideMotor");
        In this we tell the program or Android Studios that the things we named above are peices of harware on the robot.
        This is the motor used for the linear slides attached to the glyph manipulator

        IVFSM = slideMotor.getCurrentPosition();
        In this we define what the variable we created above is valued at.



        rightWheelMotorFront.setDirection(DcMotor.Direction.REVERSE);
        rightWheelMotorBack.setDirection(DcMotor.Direction.REVERSE);
        In the mechanical design of the robot the right wheels turn the opposite direction than the left wheels when the same power value is given to them
        We reverse the right wheels to avoid confusion later in the program


        glyphServoLeft.setPosition(0.5);
        glyphServoRight.setPosition(0.35);
        Here we set the glyph manipulator to the open position by moving a servo to the shown values.
        Servos are moved by setting a value to them ranging from 1-0. You have to guess and check with servos.





    }

    @Override
    public void loop() {
    This public void or loop() is what runs after the init is completed and the play button is selected.
    This is an automatic part of TeleOp program
        FourWheelDrive();
        slideMove();
        glyphManipulator();
        slideIncrement();
        These are functions or different sets of instructions that all control different parts of the robot.
        Functions are used to keep a program organized.


    }


    Functions go here
 */

    public void FourWheelDrive() {
        /*

        read the gamepad values and put them into variables
         */
        float leftY_gp1 = (-gamepad1.left_stick_y);
        float rightY_gp1 = (-gamepad1.right_stick_y);
     floats are decimals but less precise. A precise decimal is a double. A less precise decimal is a float
     the gamepad1.left/right_stick_y are the values of the joysticks on the gamepads on the y axis or up and down.

        if (gamepad1.left_trigger > 0) {
        Here we say if the left trigger is hit strafe to the left by setting power to the motors to turn the mecanum wheels in the right way.

            leftWheelMotorFront.setPower(-1);
            leftWheelMotorBack.setPower(1);
            rightWheelMotorFront.setPower(1);
            rightWheelMotorBack.setPower(-1);

        } else if (gamepad1.right_trigger > 0) {
        Here we say if the right trigger is hit strafe to the right by setting power to the motors to turn the mecanum wheels in the right way.
            leftWheelMotorFront.setPower(1);
            leftWheelMotorBack.setPower(-1);
            rightWheelMotorFront.setPower(-1);
            rightWheelMotorBack.setPower(1);

        } else {
        Otherwise we put the robot in tank drive where we say if the left joystcik is pushed up or down move the left wheels forward or backward.
        The same goes for the right wheels.
            leftWheelMotorFront.setPower(leftY_gp1);
            leftWheelMotorBack.setPower(leftY_gp1);
            rightWheelMotorFront.setPower(rightY_gp1);
            rightWheelMotorBack.setPower(rightY_gp1);
        }



    }

    public void slideMove() {

        slideMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        IVFSM = slideMotor.getCurrentPosition();

        if (gamepad2.right_stick_y != 0) {
        Here we say if on the second gamepad the right stick isn't equal to 0 move the linear slides proportionally to the amount of movement
        on the joystick.

            slideMotor.setPower(gamepad2.right_stick_y);

        }
    }

    public void glyphManipulator() {


        if (gamepad1.left_bumper   the left bumper is a boolean so we don't need a <0 or>0) {
If on gamepad1 the left bumper is clicked open the claw by setting the servos to the below positions
//opening the claw
            glyphServoRight.setPosition(0.35);

            glyphServoLeft.setPosition(0.5);
        } else if (gamepad1.right_bumper     the right bumper is a boolean so we don't need a <0 or>0) {
If on gamepad1 the Right bumper is clicked open the claw by setting the servos to the below positions
            glyphServoRight.setPosition(0.05);

            glyphServoLeft.setPosition(0.85);


        }

    }

    public void slideIncrement() {
We have the cleaned function here for slide increment to keep the program clean
The functions moveUpInch and moveDownInch are programed below
       if (gamepad2.dpad_down)
        {
If on the dpad the up or down arrow is clicked the linear slides move up or down 2.54 cm.
            moveUpInch(2.54);

        }
    if (gamepad2.dpad_up)
        {
            moveUpInch(-2.54);
        }
        else {

        }
    }

     public void moveUpInch(double cm     Here we say we need input on how many cm to move) {

        double target_Position;
        This double is defined below

        double countsPerCM = 609.6;
        The motor down't understand cm. so we have to translate it into something it understands or ticks/counts

        double finalTarget = cm*countsPerCM;
        This is the final stage where we convert the amount of cm. inputted to what the motor understands

        target_Position = slideMotor.getCurrentPosition() + finalTarget;
        Here we say add to the current position of the motor how many more ticks we want to move and store it in a variable


        slideMotor.setTargetPosition((int)target_Position);
        This is where we tell the motor what position it is going to move to.

        slideMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION));
        This is where we tell the motor to keep running until a certain position

        slideMotor.setPower(-0.6);
        We set power to the motor here

        while (slideMotor.isBusy()){
            This loop says while motor is busy wait or otherwise known as while the motor still has to move wait for it to reach the final target position
        }

        slideMotor.setPower(0);
        Once the motor has reached the target position we turn it off.

    }

   ppublic void moveUpInch(double cm) {
        double target_Position;
        This double is defined below

        double countsPerCM = 609.6;
         The motor down't understand cm. so we have to translate it into something it understands or ticks/counts

        double finalTarget = cm*countsPerCM;
        This is the final stage where we convert the amount of cm. inputted to what the motor understands

        target_Position = slideMotor.getCurrentPosition() + finalTarget;
  Here we say add to the current position of the motor how many more ticks we want to move and store it in a variable

        slideMotor.setTargetPosition((int)target_Position);
 This is where we tell the motor what poition it is going to move to.
        slideMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
This is where we tell the motor to keep running until a certain position
        slideMotor.setPower(-0.6);
We set power to the motor here
        while (slideMotor.isBusy()){
            This loop says while motor is busy wait or otherwise known as while the motor still has to move wait for it to reach the final target position

        }

        slideMotor.setPower(0);
Once the motor has reached the target position we turn it off.
    }


}
This is the end of the program