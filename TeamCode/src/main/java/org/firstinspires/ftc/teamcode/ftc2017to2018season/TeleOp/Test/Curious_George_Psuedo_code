package org.firstinspires.ftc.teamcode.ftc2017to2018season.TeleOp;


import android.transition.Slide;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.ServoController;
Import all the pre-made funtoins into the program


/**
 * Created by Team Inspiration on 1/21/18.
 */
@TeleOp(name = "Curious George")
public class curious_george_teleop extends OpMode {
Begining of the program

    /*Delta_TeleOp is designed for and tested with the Tile Runner robot. If this program is used with another robot it may not worked.
* This is specificly made for the Tile Runner and not another pushbot or competiotion robot. However, this program is the basic design for
* simple program and could work on a different robot with simple debugging and configuration.*/

    /*
        ---------------------------------------------------------------------------------------------

       Define the actuators we use in the robot here
    */
    DcMotor leftWheelMotorFront;
    DcMotor leftWheelMotorBack;
    DcMotor rightWheelMotorFront;
    DcMotor rightWheelMotorBack;
    DcMotor slideMotor;
    Servo glyphServoRight;
    Servo glyphServoLeft;
    Servo jewel_servo;
    DcMotor relicMotor;
    Servo relicMain;
    Servo relicLeft;
    Servo relicRight;
    Declaring all the motors on the robot
    public int IVFSM;
    Declaring an integer used later for slide increment

    @Override
    public void init() {
    This is the begining of the initialize phase
        leftWheelMotorFront = hardwareMap.dcMotor.get("leftWheelMotorFront");
        leftWheelMotorBack = hardwareMap.dcMotor.get("leftWheelMotorBack");
        rightWheelMotorFront = hardwareMap.dcMotor.get("rightWheelMotorFront");
        rightWheelMotorBack = hardwareMap.dcMotor.get("rightWheelMotorBack");
        glyphServoRight = hardwareMap.servo.get("glyphServoRight");
        glyphServoLeft = hardwareMap.servo.get("glyphServoLeft");
        slideMotor = hardwareMap.dcMotor.get("slideMotor");
        jewel_servo = hardwareMap.servo.get("jewelServo");
        IVFSM = slideMotor.getCurrentPosition();
        relicMain = hardwareMap.servo.get("relicMain");
        relicLeft = hardwareMap.servo.get("relicLeft");
        relicRight = hardwareMap.servo.get("relicRight");
        relicMotor = hardwareMap.dcMotor.get("relicMotor");
        Telling that the previously declared motors and servos are pieces of hardware


        leftWheelMotorFront.setDirection(DcMotor.Direction.REVERSE);
        leftWheelMotorBack.setDirection(DcMotor.Direction.REVERSE);
        Reversing the left side so the robot moves forward when directed to
        slideMotor.setDirection(DcMotor.Direction.REVERSE);
        relicMotor.setDirection(DcMotor.Direction.REVERSE);

        openGlyph();
        jewel_servo.setPosition(0.1);
        Moving the robot into posttion for TeleOp


    }

    @Override
    public void loop() {
    This repeats over and over again after the play button is pressed
       Glyph();
       Relic();
       Drive();
       Slides();
       These are the four funtions used in the program
    }

  The funtions go down here:

public void Slides(){
This controls the linear slides attached to the glyph manipulator
    slideMove();
    slideIncrement();
}
public void Drive(){
This controls the chasis on the robot
    FourWheelDrive();
}
public void Relic() {
This controls the relic manipulator
    relicManipulator();
}
public void Glyph() {
This controls the glyph manipulator
    glyphManipulator();
    incrementOpen();
    incrementClose();
}
We have organized our program into four diferent funtions moving the four different parts of the robot

   The smaller funtions go down here:

    public void relicManipulator() {
The opens and closes the relic manipulatpor along with moving it outwards
        boolean rightBumper = gamepad2.right_bumper;
        boolean leftBumper = gamepad2.left_bumper;
        float leftY_gp2 = (-gamepad2.left_stick_y);
        boolean rightButtonY = gamepad2.y;
        boolean rightButtonA = gamepad2.a;
        boolean rightButtonX = gamepad2.x;

This moves the claw inwards and outwards
        relicMotor.setPower(leftY_gp2);

       This part below is the part dictating the grabbing of the relic:
        if (leftBumper) {
            relicLeft.setPosition(0.2);
            telemetry.addData("bumper value",relicLeft.getPosition());
            telemetry.update();

        }

       This part dictates the releasing of the relic
        if (rightBumper) {

            relicLeft.setPosition(0.5);
            telemetry.addData("bumper value",relicLeft.getPosition());
            telemetry.update();

        }
        This moves to the most outward position
        if (rightButtonY) {
            relicMain.setPosition(0.3);
            telemetry.addData("button y pressed", relicMain.getPosition());
            telemetry.update();
        }

        This was the middle poition
        if (rightButtonX) {
            relicMain.setPosition(0.45);

            telemetry.addData("button x pressed", relicMain.getPosition());
            telemetry.update();
        }

      This is the closed or stowed position
        if (rightButtonA) {
            relicMain.setPosition(1);

        }


    }

    public void FourWheelDrive() {
        /*

        read the gamepad values and put into variables
         */
        float leftY_gp1 = (-gamepad1.left_stick_y);
        float rightY_gp1 = (-gamepad1.right_stick_y);
        //
        //11/24/17 This edit was made by Colin Szeto. This was a test that we used to see if the triggers will work for the servos
        // float strafeStickLeft = (-gamepad1.left_trigger);//*leftWheelMotorFront.getMaxSpeed();
        // float strafeStickRight = (-gamepad1.right_trigger);//*leftWheelMotorFront.getMaxSpeed();
        //
        // run the motors by setting power to the motors with the game pad value

        if (gamepad1.right_trigger > 0) {

            leftWheelMotorFront.setPower(1);
            leftWheelMotorBack.setPower(-1);
            rightWheelMotorFront.setPower(-1);
            rightWheelMotorBack.setPower(1);

        } else if (gamepad1.left_trigger > 0) {

            leftWheelMotorFront.setPower(-1);
            leftWheelMotorBack.setPower(1);
            rightWheelMotorFront.setPower(1);
            rightWheelMotorBack.setPower(-1);

        } else if (gamepad1.left_stick_x != 0 || gamepad1.left_stick_y != 0 || gamepad1.right_stick_x !=0 || gamepad1.right_stick_y!=0){
            leftWheelMotorFront.setPower(leftY_gp1);
            leftWheelMotorBack.setPower(leftY_gp1);
            rightWheelMotorFront.setPower(rightY_gp1);
            rightWheelMotorBack.setPower(rightY_gp1);
        }
        else{
            leftWheelMotorBack.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
            leftWheelMotorFront.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
            rightWheelMotorBack.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
            rightWheelMotorFront.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        }


    }

    public void slideMove() {

        slideMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        IVFSM = slideMotor.getCurrentPosition();

        if (gamepad2.right_stick_y != 0) {
            slideMotor.setPower(gamepad2.right_stick_y);

        } else {
            slideMotor.setPower(0);
        }
    }

    public void glyphManipulator() {
       /* Boolean Right_Bumper = (gamepad1.right_bumper);
        Boolean Left_Bumper = (gamepad1.left_bumper);
        double right_claw = (glyphServoRight.getPosition());
        double left_claw = (glyphServoLeft.getPosition());
       */
        if (gamepad1.right_bumper&&gamepad1.left_bumper){
            middleGlyph();

        }
        else if (gamepad1.left_bumper) {

//opening the claw

            openGlyph();
        } else if (gamepad1.right_bumper) {

            closeGlyph();
        }


/*        telemetry.addData("The value of the right servo is", left_claw);
        telemetry.addData("The value of the left servo is", right_claw);
        telemetry.update();

        */
    }
    public void wait(int mSec){
        double startTime;
        double endTime;

        startTime = System.currentTimeMillis();
        endTime = startTime+mSec;

        while(endTime >= System.currentTimeMillis()){

        }
    }
    public void incrementOpen(){

        while (gamepad1.x){
            glyphServoLeft.setPosition(glyphServoLeft.getPosition()+0.05);
            glyphServoRight.setPosition(glyphServoRight.getPosition()-0.05);
            wait(300);
        }
    }
    public void incrementClose(){

        while (gamepad1.y) {
            glyphServoLeft.setPosition(glyphServoLeft.getPosition()-0.05);
            glyphServoRight.setPosition(glyphServoRight.getPosition()+0.05);
            wait(300);
        }
    }
    public void slideIncrement() {

        if (gamepad2.dpad_up) {

            moveUpInch(2.54);

        } else if (gamepad2.dpad_down) {
            moveDownInch(2.54);
        } else {

        }
    }

    public void moveUpInch(double cm) {
        double target_Position;
        double countsPerCM = 609.6;
        double finalTarget = cm * countsPerCM;
        target_Position = slideMotor.getCurrentPosition() - finalTarget;

        slideMotor.setTargetPosition((int) target_Position);

        slideMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        slideMotor.setPower(-0.6);

        while (slideMotor.isBusy()) {
            telemetry.addData("In while loop in moveUpInch", slideMotor.getCurrentPosition());
            telemetry.update();

        }

        slideMotor.setPower(0);

    }

    public void moveDownInch(double cm) {
        double target_Position;
        double countsPerCM = 609.6;
        double finalTarget = cm * countsPerCM;
        target_Position = slideMotor.getCurrentPosition() + finalTarget;

        slideMotor.setTargetPosition((int) target_Position);

        slideMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        slideMotor.setPower(0.6);

        while (slideMotor.isBusy()) {
            telemetry.addData("In while loop in moveDownInch", slideMotor.getCurrentPosition());
            telemetry.update();

        }

        slideMotor.setPower(0);

    }
    public void openGlyph(){

        //switching values with closeGlyph
        //reversed values
        glyphServoRight.setPosition(0.5);
        glyphServoLeft.setPosition(0.4);
    }

    public void closeGlyph(){
        //reversed values
        glyphServoRight.setPosition(0.7);
        glyphServoLeft.setPosition(0.2);
    }

    public void middleGlyph(){
        glyphServoRight.setPosition(0.6);
        glyphServoLeft.setPosition(0.3);
    }
}
